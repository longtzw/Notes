# 定义函数模板

模板定义以关键字 template 开始，后接 **模板形参表**，模板形参表是用尖括号括住的一个或多个 **模板形参** 的列表，形参之间用逗号分隔。

```c++
template <typename T>
int compare(const T &v1, const T &v2)
{
     ……
}
```

模板形参可以是表示类型的 **类型形参**，也可以是表示常量表达式的 **非类型形参**。

**inline 函数模板**

`template <typename T> inline T min(const T&, const T&);`

## 模板形参

>限制：模板形参的名字只能在同一模板形参表中使用一次。

像任何其他函数或类一样，模板可以只声明而不定义。同一模板的声明和定义中，模板形参的名字不必相同。

**typename 与 class 的区别**

使用关键字 typename 代替关键字 class 指定模板类型形参也许更直观，但是，关键字 typename 是作为标准C++的组成部分加入到C++中的，因此旧程序更有可能只用关键字 class。

**在模板内指定类型**

需要显示告诉编译器某个符号是一种类型：

```c++
template <class Parm, class U>
Parm fcn(Parm* array, U value)
{
     typename Parm::size_type* p; // declares p to be a pointer
}
```

模板非类型形参是模板定义内部的常量值，在需要常量表达式的时候，可使用非类型形参指定数组的长度。

对模板的非类型形参而言，求值结果相同的表达式将认为是等价的。

# 使用函数模板

使用函数模板时，编译器会推断哪个 **模板实参** 绑定到模板形参，一旦编译器确定了实际的模板实参，就称它 **实例化** 了函数模板的一个实例。

## 实例化

产生模板的特定类型实例的过程称为实例化。类模板在引用实际模板类类型时实例化，函数模板在调用它或用它对函数指针进行初始化或赋值时实例化。

## 模板实参推断

使用函数模板时，编译器通常会为我们推断模板实参。在此过程中，类型形参的实参存在**受限转换**。

一般而言，不会转换实参以匹配已有的实例化，相反，会产生新的实例。除了产生新的实例化之外，编译器只会执行两种转换：

- const 转换：接受 const 引用或指针的函数可以分别用非 const 对象的引用或指针来调用，无需产生新的实例化。如果函数接受非引用类型，形参类型和实参都忽略 const，即，无论传递 const 或非 const 对象给接受非引用类型的函数，都使用相同类型的实例化。
- 数组或函数到指针的转换：如果模板形参不是引用类型，则对数组或函数类型的实参应用常规指针转换。数组实参将当作指向其第一个元素的指针，函数实参当作指向函数类型的指针。

可以使用函数模板对函数指针进行初始化或赋值，这样做的时候，编译器使用指针的类型实例化具有适当模板实参的模板版本。

## 显示实参

在某些情况下，不可能推断模板实参的类型。当函数返回类型必须与形成表中所用的所有类型都不同时，最常出现这一问题。

显示模板实参从左至右与对应模板形参相匹配，第一个模板实参与第一个模板形参匹配，第二个模板实参与第二个形参匹配。

# 模板特化

**模板特化** 对模板的用户透明。对用户而言，调用特化函数或使用特化类与使用从通用模板实例化的版本无区别。同时解决了通用模板对部分类型的不适用问题。

## 定义模板特化

特化的形式如下：

- 关键字 template 后面接一对空的尖括号；
- 再接模板名和一对尖括号，尖括号中指定这个特化定义的模板形参；
- 函数形参表；
- 函数体

```c++
template <>
int compare<const char*>(const char* const& v1, const char* const& v2)
{
     ……
}
```

当特化模板的时候，对实参类型不应用转换。在模板特化版本的调用中，实参类型必须与特化版本函数的形参类型完全匹配，如果不完全匹配，编译器将为实参从模板定义实例化一个实例。

与其他函数声明一样，应在一个头文件中包含模板特化的声明，然后使用该特化的每个源文件包含该头文件。

# 重载与函数模板

函数模板可以重载；可以定义有相同名字但形参数目或类型不同的多个函数模板，也可以定义与函数模板有相同名字的普通非模板函数。
