#让自己习惯 C++

##条款01：视 C++ 为一个语言联邦

C++ 的四个主要组成部分：

- C语言
- Object-Oriented C++
- Template C++
- STL

##条款02：尽量以 const，enum，inline 替换 #define

当我们以常量替换 #define，有两种特殊情况值得说说：

第一是定义常量指针。由于常量定义式通常被放在头文件中，因此有必要将指针声明为 const。

`const char* const authorName = "tan zhiwei";`

第二个值得注意的是类的专属常量，为了确保此变量至多只有一份实体，你必须让它成为一个 static 成员。

```c++
class GamePlayer {
private:
    static const int NumTurns = 5; // 常量声明式
    int  scores[NumTurns];         // 使用该常量
}
```

若类的专属常量为整数类型（例如： int, bool），则只要不取常量的地址，可以不提供定义式。其他类型的常量，必须提供
定义式。

##条款03：尽可能使用 const

如果关键字 const 出现在星号左边，表示被指物是常量；如果出现在星号右边，表示指针自身是常量。
后者表示这个指针不得指向不同的东西，但它所指向的东西的指是可以变的。

**const 成员函数**

将 const 实施于成员函数的目的，是为了确认该成员函数可以用作 const 对象身上。

两个成员函数如果只是常量性不同，可以被重载。

有两个流行的概念：bitwise constness（又称 physical constness）和 logical constness。前者认为成员函数只有在不更
改对象之任何成员变量（static 除外）时才可以说是 const。后者认为，一个 const成员函数可以修改它所处理的对象的某些 bits，
但是只有在客户端侦测不出的情况下。

关键字 mutable 可以释放掉 non-static 成员变量的 bitwise constness 约束。

在 const 和 non-const 成员函数中避免重复，可以运用 const 成员函数实现其 non-const 兄弟，但是反之则是不行的。因
为，const 成员函数承诺绝不改变其对象的逻辑状态，non-const 成员函数却没有这般承诺。

- 编译器强制实施 bitwise constness， 但你编写程序时应该使用“概念上的常量性”，mutable 可以帮助你。

##条款04：确定对象被使用前已先被初始化

C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前。

成员初始化列会调用成员的 copy 构造函数或 default 构造函数。如果成员变量是const 或 reference，它们就一定需要初
值，不能被赋值。

若 class 拥有多个构造函数，多份成员初始化列的存在就会导致重复工作。合理地在初值列中遗漏那些“赋值变现像初始化一
样好”的成员变量，改用它们的赋值操作，并将那些赋值操作移往某个函数，供所有构造函数调用。

不同编译单元内定义之 non-local static 对象的初始化次序无明确定义。改用 Singleton 模式是个不错的解决办法。

#构造/析构/赋值运算

##条款05：了解C++默默编写并调用哪些函数

编译器产出的析构函数是个 non-virtual。

编译器拒绝为以下情况生成对应的 copy 构造函数和赋值构造函数：

- 内含 reference 成员的 class。
- 内含 const 成员的 class。
- base class 将 copy 或 赋值构造声明为 private 的 derived class。

##条款06：若不想使用编译器自动生成的函数，就该明确拒绝

将成员函数声明为 private 而且故意不实现它们。

##条款07：为多态基类声明 virtual 析构函数

C++ 明确指出，当 derived class 对象经由一个 base class 指针被删除，而该 base class 带着一个 non-virtual 析构函数，其结果未定义。

不要企图继承一个标准容器或任何其他“带有 non-virtual 析构函数”的class。

当你希望拥有抽象 class，你可以为它声明一个 pure virtual 析构函数，且必须为其提供一份定义，否则会出现链接错误。

Class 的设计目的如果不是作为 base classes 使用，或不是为了具备多态性，就不该声明 virtual 析构函数。

##条款08：别让异常逃离析构函数

- 析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们或结束程序。
- 如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 class 应该提供一个普通函数（而非在析构函数中）执行该操作。

##条款09：绝不在构造和析构过程中调用 virtual 函数

##条款10：令 operator= 返回一个 reference to \*this

为了实现“连锁赋值”，赋值操作符必须返回一个 reference 指向操作符左侧的实参。

##条款11：在 operator= 中处理“自我赋值”

让 operator= 具备“异常安全性”往往自动获得“自我赋值安全”的回报。一群精心安排的语句就可以导出异常安全的代码。

```c++
Widget& Widget::operator=(const Widget& rhs)
{
     Bitmap *pOrig = pb;
     pb = new Bitmap(*rhs.pb);
     delete pOrig;
     return *this;
}
```

##条款12：复制对象时勿忘其每一个成分

如果你为 class 添加一个成员变量，你必须同时修改 copying 函数。

- Copying 函数应该确保复制“对象内的所有成员变量”及“所有 base class 成分”。
- 不要尝试以某个 copying 函数实现另一个 copying 函数。应该将共同机能放进第三个函数中，并由两个 copying 函数共同调用。

#资源管理

所谓资源就是，一旦用了它，将来必须还给系统。

##条款13：以对象管理资源

把资源放进对象内，我们便可以倚赖 C++ 的”析构函数自动调用机制“确保资源被释放。

许多资源被动态分配于 heap 内而后被用于单一区块或函数内。它们应该在控制流离开那个区块或函数时被释放。标准程序库提供的 auto_ptr 正式针对这种形势而设计的特制产品。

由于 auto_ptr 被销毁时会自动删除它所指之物，所以一定要注意别让多个 auto_ptr 同时指向同一对象。如果真是那样，对象被删除一次以上，而那会使你的程序搭上驶向”未定义行为“的快速列车上。为了预防这个问题，auto_ptrs 有一个不寻常的性质：若通过 copy 构造函数或 copy assignment 操作符复制它们，它们会变成 null，而复制所得的指针将取得资源的唯一使用权。

STL 容器要求其元素发挥”正常的“复制行为，因此这些容器容不得 auto_ptr。

auto_ptr 和 tr1::shared_ptr 两者都是在其析构函数内做 delete 而不是 delete[] 动作。那意味在动态分配而得的 array 身上使用 auto_ptr 或 tr1::shared_ptr 是个馊主意。

## 条款14：在资源管理类中小心 copying 行为

class 析构函数(无论是编译器生成的，或用户自定义的)会自动调用其 non-static 成员变量的析构函数。

普遍而常见的 RAII class copying 行为是：抑制 copying、施行引用计数法。

## 条款15：在资源管理类中提供对原始资源的访问

## 条款16：成对使用 new 和 delete 时采取相同形式

## 条款17：以独立的语句将 newed 对象置入智能指针

# 设计与声明

## 条款18：让接口容易被正确使用，不易被误用

- “促进正确使用”的办法包括接口的一致性，以及内置类型的行为兼容。

## 条款19: 设计 class 犹如设计 type

## 条款 20: 宁以 pass-by-reference-to-const 替换 pass-by-value

- 以上规则并不适用于内置类型，以及 STL 的迭代器和函数对象。对它们而言，pass-by-value 往往比较适当。

## 条款21: 必须返回对象时，别妄想返回其 reference。

任何函数如果返回一个 reference 指向某个 local 对象，都将一败涂地。

## 条款22: 将成员变量声明为 private

## 条款23: 宁以 non-member、non-friend 替换 member 函数

我们推崇封装的原因：它使我们能够改变事物而只影响有限的客户。

non-member non-friend 函数不增加“能够访问 class 内之 private 成分”的函数数量。

将所有便利函数放在多个头文件内但隶属同一个命名空间，意味客户可以轻松扩展这一组便利函数。

## 条款24: 若所有参数皆需要类型转换，请为此采用 non-member 函数

member 函数的反面是 non-member 函数，不是 friend 函数。如果可以避免 friend 函数就应该避免。

## 条款 25: 考虑写一个不抛异常的 swap 函数

客户可以全特化 std 内的 templates，但不可以添加新的 templates（或 classes 或 functions 或其他任何东西）到 std 里头。std 的内容完全由标准委员会决定，标准委员会禁止我们膨胀那些已经声明好的东西。

成员版的 swap 绝不抛出异常，因为 swap 缺省版本是以 copy 构造函数和 copy assignment 操作符为基础，而一般情况下两者都允许抛出异常。因此你写一个自定义版本的 swap，往往提供的不只是高效置换对象值的办法，而且不抛出异常。

```c++
typedef std::string AddressLines[4]; // 每个人的地址有4行，每行是一个 string

// AddressLines 是一个数组。
```

最好尽量不要对数组形式做 typedef 动作。

# 实现

## 条款26: 尽可能延后变量定义式的出现时间

你不只应该延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该延后这份定义直到能够给它初值实参为止。

## 条款27: 尽量少做转型动作

## 条款28: 避免返回 handles 指向对象内部成分

References、指针和迭代器统统都是所谓的 handles，而返回一个“代表对象内部数据”的handle。随之而来的便是“降低对象封装性”的风险。

- 本条款帮助 const 成员函数的行为像个 const，并将发生“虚拟号牌”（handle 比其所指对象更长寿）的可能性降至最低。

## 条款29: 为“异常安全”而努力是值得的

当异常被抛出时，带有异常安全性的函数会：

- 不泄漏任何资源。
- 不允许数据败坏。

异常安全函数提供以下三个保证之一：

- 基本承诺：如果异常被抛出，程序内的任何事物仍然保持在有效的状态下。没有任何数据对象或数据结构会因此而败坏。
- 强烈保证：程序状态不改变。
- 不拋掷保证。

当你撰写新代码或修改旧代码时，请仔细想想如何让它具备异常安全性，首先是“以对象管理资源”，可以阻止资源泄漏。然后挑选三个“异常安全保证”中的一个实施于你所写的每一个函数身上。

## 条款30: 透彻了解 inlining 的里里外外

inline 只是对编译器的一个申请，不是强制命令。

inline 函数通常被置于头文件中，因为大多数构建环境在编译过程中进行 inlining，而为将一个“函数调用”替换为“被调用函数的本体”，编译器必须知道那个函数长什么样子。

Template 通常也被置于头文件内，因为它一旦被使用，编译器为了将它具现化，需要知道它长什么样子。

大部分编译器拒绝将太过复杂（例如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用也会使 inlining 落空。

平均而言一个程序往往将80%的执行时间花在20%的代码上，你的目标应该是找出这可以有效增进程序整体效率的20%代码。

## 条款31: 将文件间的编译关系将至最低

**不该尝试手工声明一部分标准程序库。**

- 如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects。
- 如果能够，尽量以 class 声明式替代 class 定义式。
- 为声明式和定义式提供不同的头文件。

Interface classs 的目的是详细一一描述 derived class 的接口，因此它通常不带成员变量，也没有构造函数，只有一个 virtual 析构函数以及一组 pure virtual 函数，用来叙述这个接口。

handle class 和 interface class 解除了接口和实现之间的耦合关系。

# 继承和面向对象设计

"Public 继承"意味"is-a"，如果你尝试让它带其他意义，你会惹祸上身。同样的道理，virtual函数意味"接口必须被继承"，non-virtual函数意味“接口和实现都必须被继承”。

## 条款32: 确定你的public继承塑模出is-a关系

## 条款33: 避免遮掩继承而来的名称

- derived class 内的名称会遮掩 base class 内的名称。在public继承下从来没有人希望如此。
- 为了让被遮掩的名称再见天日，可使用using声明式或转交函数。

## 条款34: 区分接口继承和实现继承

- 声明一个pure virtual函数的目的是为了让derived class只继承函数接口。
- 声明简朴的 impure virtual函数的目的，是让 derived class继承该函数的接口和缺省实现。
- 声明non-virtual函数的目的是为了令derived class继承函数的接口及一份强制性实现。

pure virtual函数必须在derived class中重新声明，但它们也可以拥有自己的实现。

## 条款35: 考虑virtual函数以外的其他选择

- virtual函数的替代方案包括NVI手法及strategy设计模式的多种形式。NVI手法自身是一个特殊的 Template Method 设计模式。
- 将机能从成员函数移到class外部函数，带来一个缺点是，非成员函数无法访问class的non-public成员。
- tr1::function 对象的行为就像一般函数指针。这样的对象可接纳“与给定之目标签名式兼容”的所有可调用物。

##条款36: 绝不重新定义继承而来的non-virtual函数

non-virtual函数都是静态绑定的，virtual函数却是动态绑定的。

##条款37: 绝不重新定义继承而来的缺省参数值

对象的所谓静态类型，就是它在程序中被声明时所采用的类型。对象的动态类型则是指“目前所指对象的类型”。

virtual函数是动态绑定，缺省参数却是静态绑定。这意味着你可能会在“调用一个定义于derived class内的virtual函数”的同时，却使用base class为它所指定的缺省参数值。
